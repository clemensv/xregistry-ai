name: Deploy to Azure Web Sites (App Service)

on:
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Azure App Service name'
        required: true
        type: string
      resource_group:
        description: 'Azure Resource Group'
        required: false
        type: string
      force_rebuild:
        description: 'Force rebuild of registry data'
        required: false
        default: false
        type: boolean
  
  # Run after static site build completes
  workflow_run:
    workflows: ["Build static content into static-site branch"]
    types:
      - completed

permissions:
  contents: read
  id-token: write

concurrency:
  group: "azure-web-sites"
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    # Only run if Azure credentials are configured or manual dispatch
    if: vars.ENABLE_AZURE_WEBSITESAPI == 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Check Azure Configuration
        run: |
          if [ -z "${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}" ] && [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then
            echo "⚠️  Azure Web Sites credentials not configured."
            echo "To enable Azure Web Sites deployment:"
            echo "1. Create an Azure App Service"
            echo "2. Add either:"
            echo "   - AZURE_WEBAPP_PUBLISH_PROFILE secret with publish profile"
            echo "   - Or Azure Service Principal credentials (AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_SUBSCRIPTION_ID)"
            echo "3. Set ENABLE_AZURE_WEBSITESAPI variable to 'true'"
            if [ "${{ github.event_name }}" != "workflow_dispatch" ]; then
              echo "Skipping deployment due to missing configuration."
              exit 1
            fi
          else
            echo "✅ Azure Web Sites configuration found"
          fi

      - name: Checkout main repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Set up Git
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install Python dependencies
        run: |
          pip install jsonpointer pandas
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Set Repository Variables
        run: |
          APP_NAME="${{ inputs.app_name || vars.AZURE_APP_NAME || 'xregistry-ai' }}"
          AZURE_URL="https://${APP_NAME}.azurewebsites.net"
          echo "AZURE_URL=$AZURE_URL" >> $GITHUB_ENV
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          echo "Repository: ${{ github.repository }}"
          echo "Azure URL: $AZURE_URL"
      
      - name: Generate unified schemas
        run: |
          cd xreg
          echo "Generating unified schemas for all protocols..."
          python schema-generator.py --models --type json-schema --output ../schema/json-schema.json
          python schema-generator.py --models --type openapi --output ../openapi/openapi.json
          python schema-generator.py --models --type avro-schema --output ../schema/avro-schema.json
          echo "Schema generation complete"
      
      - name: Start xRegistry server for data export
        run: |
          echo "Starting xRegistry server container..."
          CONTAINER_NAME="xregistry-server"
          
          # Check if container already exists and remove it
          if [ "$(docker ps -aq -f name=${CONTAINER_NAME})" ]; then
            docker stop "${CONTAINER_NAME}" || true
            docker rm "${CONTAINER_NAME}" || true
          fi
          
          # Start new container
          CONTAINER_ID=$(docker run -d --name "${CONTAINER_NAME}" \
            -v $GITHUB_WORKSPACE:/workspace \
            -p 8080:8080 \
            ghcr.io/xregistry/xrserver-all --recreatedb)
          
          echo "CONTAINER_ID=$CONTAINER_ID" >> $GITHUB_ENV
          echo "CONTAINER_NAME=$CONTAINER_NAME" >> $GITHUB_ENV
          
          # Wait for server to be ready
          echo "Waiting for xregistry server to be ready..."
          max_attempts=30
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if curl --silent --get http://localhost:8080 -I | grep "200 OK" > /dev/null; then
              echo "Server is ready!"
              break
            fi
            echo "Waiting for server... (attempt $((attempt+1))/$max_attempts)"
            sleep 10
            attempt=$((attempt+1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "Server failed to start within expected time"
            docker logs "${CONTAINER_NAME}"
            exit 1
          fi
      
      - name: Update registry model and populate data
        run: |
          echo "Updating registry model..."
          
          # Use the unified model from our generated schemas
          # Create a temporary combined model file
          TEMP_MODEL=$(mktemp)
          cat > "$TEMP_MODEL" << 'EOF'
          {
            "groups": {
              "agentcardproviders": {
                "plural": "agentcardproviders",
                "singular": "agentcardprovider",
                "description": "Organizations providing agent cards for the Agent-to-Agent protocol",
                "resources": {
                  "agentcards": {
                    "plural": "agentcards", 
                    "singular": "agentcard",
                    "description": "Agent card definitions following the A2A protocol",
                    "attributes": {
                      "name": {"type": "string", "required": true},
                      "version": {"type": "string", "required": true},
                      "description": {"type": "string"},
                      "manifestUrl": {"type": "string", "format": "uri"}
                    }
                  }
                }
              },
              "mcpproviders": {
                "plural": "mcpproviders",
                "singular": "mcpprovider", 
                "description": "Organizations providing Model Context Protocol servers",
                "resources": {
                  "servers": {
                    "plural": "servers",
                    "singular": "server",
                    "description": "MCP server implementations",
                    "attributes": {
                      "name": {"type": "string", "required": true},
                      "version": {"type": "string", "required": true},
                      "description": {"type": "string"},
                      "manifestUrl": {"type": "string", "format": "uri"}
                    }
                  }
                }
              }
            }
          }
          EOF
          
          docker exec "${CONTAINER_ID}" /xr model update /dev/stdin -s localhost:8080 < "$TEMP_MODEL"
          rm "$TEMP_MODEL"
          
          # Create entries for each registry index.json
          echo "Creating registry entries..."
          docker exec "${CONTAINER_ID}" /bin/sh -c '
            REGISTRY_DIR=/workspace/registry
            find $REGISTRY_DIR -type f -name index.json | while read file; do
              path=${file#"$REGISTRY_DIR"/}
              path=${path%/index.json}
              echo "Processing: $path -> $file"
              /xr create "$path" -d "@$file" -s localhost:8080
              if [ $? -ne 0 ]; then
                echo "Error processing file: $file"
              else
                echo "Successfully processed file: $file"
              fi 
            done
          '
      
      - name: Export registry data for Azure Web Sites
        run: |
          echo "Exporting live registry data..."
          DATA_EXPORT_DIR="$GITHUB_WORKSPACE/azure-api"
          mkdir -p "$DATA_EXPORT_DIR"
          
          # Export live data specifically for Azure Web Sites API
          docker exec "${CONTAINER_ID}" /bin/sh -c "
            mkdir -p /tmp/live
            /xr download -s localhost:8080 /tmp/live -u $AZURE_URL/api/registry --index index.html
          "
          
          # Copy exported data to host
          docker cp "${CONTAINER_ID}:/tmp/live/." "$DATA_EXPORT_DIR/"
          
          echo "Registry data exported to $DATA_EXPORT_DIR"
          ls -la "$DATA_EXPORT_DIR"
      
      - name: Post-process registry data for IIS/Azure Web Sites
        run: |
          echo "Post-processing registry data for Azure Web Sites..."
          chmod +x xreg/azure-webapi-postprocess.mjs
          node xreg/azure-webapi-postprocess.mjs "$GITHUB_WORKSPACE/azure-api"
          
          echo "Post-processing complete. Files after processing:"
          find "$GITHUB_WORKSPACE/azure-api" -name "*.json" | head -10
          find "$GITHUB_WORKSPACE/azure-api" -name "web.config" | head -5
      
      - name: Create deployment package
        run: |
          cd "$GITHUB_WORKSPACE/azure-api"
          
          # Create basic ASP.NET Core API structure
          mkdir -p wwwroot/api/registry
          
          # Move all registry content to wwwroot/api/registry
          rsync -av . wwwroot/api/registry/ --exclude=wwwroot
          
          # Create minimal ASP.NET Core app
          cat > Program.cs << 'EOF'
          var builder = WebApplication.CreateBuilder(args);
          
          builder.Services.AddCors(options =>
          {
              options.AddDefaultPolicy(policy =>
              {
                  policy.AllowAnyOrigin()
                        .AllowAnyMethod()
                        .AllowAnyHeader();
              });
          });
          
          var app = builder.Build();
          
          app.UseCors();
          app.UseStaticFiles();
          
          app.MapGet("/", () => "xRegistry API for AI - Azure Web Sites");
          app.MapGet("/health", () => new { status = "healthy", timestamp = DateTime.UtcNow });
          
          app.Run();
          EOF
          
          # Create project file
          cat > azure-api.csproj << 'EOF'
          <Project Sdk="Microsoft.NET.Sdk.Web">
            <PropertyGroup>
              <TargetFramework>net8.0</TargetFramework>
              <Nullable>enable</Nullable>
              <ImplicitUsings>enable</ImplicitUsings>
            </PropertyGroup>
          </Project>
          EOF
          
          echo "Created Azure Web Sites deployment package"
          ls -la
      
      - name: Clean up xRegistry server
        if: always()
        run: |
          if [ -n "$CONTAINER_ID" ]; then
            echo "Stopping and removing xregistry server..."
            docker stop "${CONTAINER_ID}" || true
            docker rm "${CONTAINER_ID}" || true
            echo "Container cleanup complete"
          fi
      
      # Deploy using publish profile if available
      - name: Deploy to Azure Web Sites (Publish Profile)
        if: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE != '' }}
        uses: azure/webapps-deploy@v3
        with:
          app-name: ${{ env.APP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: '${{ github.workspace }}/azure-api'
      
      # Alternative deployment using Azure CLI (requires service principal)
      - name: Azure Login (Service Principal)
        if: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE == '' && secrets.AZURE_CLIENT_ID != '' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Deploy to Azure Web Sites (CLI)
        if: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE == '' && secrets.AZURE_CLIENT_ID != '' }}
        run: |
          cd "$GITHUB_WORKSPACE/azure-api"
          zip -r ../deployment.zip .
          
          az webapp deployment source config-zip \
            --resource-group "${{ inputs.resource_group || vars.AZURE_RESOURCE_GROUP || 'xregistry-rg' }}" \
            --name "${{ env.APP_NAME }}" \
            --src ../deployment.zip
      
      - name: Deployment Summary
        if: success()
        run: |
          echo "🚀 Azure Web Sites deployment completed!"
          echo "🌐 Site URL: ${{ env.AZURE_URL }}"
          echo "📋 Registry API: ${{ env.AZURE_URL }}/api/registry/"
          echo "🔍 Health Check: ${{ env.AZURE_URL }}/health"
          echo "📊 Schema: ${{ env.AZURE_URL }}/api/registry/schema/json-schema.json"
          echo "🔧 OpenAPI: ${{ env.AZURE_URL }}/api/registry/openapi/openapi.json"

  # Deployment check job
  check-deployment:
    runs-on: ubuntu-latest
    if: always() && needs.build-and-deploy.result == 'skipped'
    needs: build-and-deploy
    steps:
      - name: Azure Web Sites Deployment Status
        run: |
          echo "ℹ️  Azure Web Sites deployment was skipped."
          echo ""
          echo "To enable Azure Web Sites deployment:"
          echo "1. Create an Azure App Service in the Azure portal"
          echo "2. Add either:"
          echo "   - AZURE_WEBAPP_PUBLISH_PROFILE secret (download from Azure portal)"
          echo "   - Or Service Principal credentials:"
          echo "     * AZURE_CLIENT_ID"
          echo "     * AZURE_TENANT_ID" 
          echo "     * AZURE_SUBSCRIPTION_ID"
          echo "3. Set repository variables:"
          echo "   - ENABLE_AZURE_WEBSITESAPI='true'"
          echo "   - AZURE_APP_NAME='your-app-name'"
          echo "   - AZURE_RESOURCE_GROUP='your-resource-group' (if using CLI)"
          echo ""
          echo "Or run this workflow manually to test with different settings." 